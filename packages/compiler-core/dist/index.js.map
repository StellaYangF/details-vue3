{
  "version": 3,
  "sources": ["../src/codegen.ts", "../src/parse.ts", "../../shared/src/generals.ts", "../src/runtimeHelpers.ts", "../src/transform.ts", "../src/compile.ts"],
  "sourcesContent": ["export function generate(ast) { }", "import {\n  ElementNode,\n  InterpolationNode,\n  NodeTypes,\n  ParserContext,\n  Position,\n  RootNode,\n  SourceLocation,\n  TemplateChildNode,\n  TextNode\n} from \"./ast\"\n\nfunction createParserContext(content: string) {\n  return {\n    line: 1,\n    column: 1,\n    offset: 0,\n    source: content,\n    originalSource: content\n  }\n}\n\n// TODO: RootNode should be returned.\nexport function baseParse(content: string): RootNode {\n  const context = createParserContext(content)\n  const start = getCursor(context)\n  return createRoot(\n    parseChildren(context),\n    getSelection(context, start)\n  )\n}\n\nfunction createRoot(children, loc): RootNode {\n  return {\n    type: NodeTypes.ROOT,\n    children,\n    loc,\n    helpers: new Set()\n  }\n}\n\nfunction parseChildren(\n  context: ParserContext\n): TemplateChildNode[] {\n  const nodes: TemplateChildNode[] = []\n\n  while (!isEnd(context)) {\n    const s = context.source\n    let node\n    if (s.startsWith('{{')) {\n      node = parseInterpolation(context)\n    } else if (s[0] === '<') {\n      node = parseElement(context)\n    }\n    if (!node) {\n      node = parseText(context)\n    }\n\n    nodes.push(node)\n  }\n\n  return nodes\n}\n\nconst isEnd = (context: ParserContext): boolean => {\n  const source = context.source\n  if (context.source.startsWith('</')) { // denote no children\n    return true\n  }\n  return !source\n}\n\nfunction parseText(context): TextNode {\n  // Hello {{name}}</div> | Hello </div>{{name}}\n  const endTokens = ['<', '{']\n  let endIndex = context.source.length\n\n  for (let i = 0; i < endTokens.length; i++) {\n    const index = context.source.indexOf(endTokens[i], 1)\n    if (index !== -1 && endIndex > index) {\n      endIndex = index\n    }\n  }\n\n  let start = getCursor(context)\n  const content = parseTextData(context, endIndex)\n\n  return {\n    type: NodeTypes.TEXT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction getCursor(\n  context: ParserContext\n): Position {\n  const { column, line, offset } = context\n\n  return { column, line, offset }\n}\n\nfunction parseTextData(\n  context: ParserContext,\n  endIndex: number\n): string {\n\n  const rawText = context.source.slice(0, endIndex)\n  advanceBy(context, endIndex)\n  return rawText\n}\n\nfunction advanceBy(\n  context: ParserContext,\n  numberOfCharacters: number\n): void {\n  const s = context.source\n  advancePositionWithMutation(context, s, numberOfCharacters)\n  context.source = s.slice(numberOfCharacters)\n}\n\n// update context\nfunction advancePositionWithMutation(\n  pos: Position,\n  source: string,\n  numberOfCharacters: number\n): Position {\n  let linesCount = 0\n  let linePos = -1\n  for (let i = 0; i < numberOfCharacters; i++) {\n    if (source.charCodeAt(i) === 10) { // \\n new line\n      linesCount++\n      linePos = i\n    }\n  }\n  pos.offset += numberOfCharacters\n  pos.line += linesCount\n  pos.column = linePos === -1\n    ? pos.column + numberOfCharacters\n    : numberOfCharacters - linePos\n\n  return pos\n}\n\nfunction getSelection(\n  context: ParserContext,\n  start: Position,\n  end?: Position\n): SourceLocation {\n  end = end || getCursor(context)\n  return {\n    start,\n    end,\n    source: context.originalSource.slice(start.offset, end.offset)\n  }\n}\n\nfunction parseInterpolation(\n  context: ParserContext\n): InterpolationNode | undefined {\n  // {{state.name}}\n  const [open, close] = ['{{', '}}']\n  const closeIndex = context.source.indexOf(close, open.length)\n\n  if (closeIndex === -1) {\n    // EmitError\n    return undefined\n  }\n\n  const start = getCursor(context)\n  advanceBy(context, open.length)\n  const innerStart = getCursor(context)\n  const innerEnd = getCursor(context)\n  const rawContentLength = closeIndex - open.length\n  const rawContent = context.source.slice(0, rawContentLength)\n  const preTrimContent = parseTextData(context, rawContentLength)\n  const content = preTrimContent.trim()\n  const startOffset = preTrimContent.indexOf(content)\n  if (startOffset > 0) {\n    advancePositionWithMutation(innerStart, rawContent, startOffset)\n  }\n  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset)\n  advancePositionWithMutation(innerEnd, rawContent, endOffset)\n  advanceBy(context, close.length)\n\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      isStatic: false,\n      content,\n      loc: getSelection(context, innerStart, innerEnd)\n    },\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseElement(context: ParserContext): ElementNode | undefined {\n  const ele = parseTag(context, TagType.Start)\n  const children = parseChildren(context)\n\n  if (context.source.startsWith('</')) {\n    parseTag(context, TagType.End)\n  }\n  ele.loc = getSelection(context, ele.loc.start)\n  ele.children = children\n  return ele\n}\n\nconst enum TagType {\n  Start,\n  End\n}\n\nfunction parseTag(context: ParserContext, type: TagType.Start): ElementNode\nfunction parseTag(context: ParserContext, type: TagType.End): void\nfunction parseTag(context: ParserContext, type: TagType): ElementNode | undefined {\n  const start = getCursor(context)\n  // <div id=\"\"></div>\n  const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source)\n  const tag = match[1] // <div\n  advanceBy(context, match[0].length)\n  advanceSpaces(context)\n  const isSelfClosing = context.source.startsWith('/>') //<slot />\n  advanceBy(context, isSelfClosing ? 2 : 1)\n\n  if (type === TagType.End) {\n    return\n  }\n\n  return {\n    type: NodeTypes.ELEMENT,\n    tag,\n    isSelfClosing,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction advanceSpaces(context: ParserContext): void {\n  const match = /^[\\t\\r\\n]+/.exec(context.source) // null\n  if (match) {\n    advanceBy(context, match[0].length)\n  }\n}", "export function isObject(val) {\n  return val !== null && typeof val === 'object'\n}\n\nexport function isFunction(val) {\n  return typeof val === 'function'\n}\n\nexport const isArray = Array.isArray\n\nconst onRE = /^on[^a-z]/\nexport const isOn = (key: string) => onRE.test(key)\n\nexport const isString = (val: unknown): val is string => typeof val === 'string'\n\nexport const EMPTY_OBJ: { readonly [key: string]: any } = {}\n\nexport const NO = () => false\n\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (\n  val: object,\n  key: string | symbol\n): key is keyof typeof val => hasOwnProperty.call(val, key)\n\nexport const invokeArrayFns = fns => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i]()\n  }\n}", "export const TO_DISPLAY_STRING = Symbol(``)", "import { NO, isArray, isString } from \"@vue/shared\"\nimport { NodeTypes, ParentNode, RootNode, TemplateChildNode } from \"./ast\"\nimport { TO_DISPLAY_STRING } from \"./runtimeHelpers\"\n\nexport interface TransformContext {\n  root: RootNode\n  helpers: Map<symbol, number>\n  parent: ParentNode\n  currentNode: RootNode | TemplateChildNode | null\n  helper<T extends symbol>(name: T): T\n  removeHelper<T extends symbol>(name: T): void\n  nodeTransforms: Array<any>\n  childIndex: number\n  onNodeRemoved(): void\n  removeNode(node?: TemplateChildNode): void\n}\n\nexport function transform(root: RootNode) {\n  const context = createTransformContext(root)\n  traverseNode(root, context)\n}\n\nfunction createTransformContext(root): TransformContext {\n  const context: TransformContext = {\n    root,\n    currentNode: root,\n    parent: null,\n    nodeTransforms: [\n      transformElement,\n      transformText,\n      transformExpression\n    ],\n    helpers: new Map(), // record transforms call nums\n    helper(name) {\n      const count = context.helpers.get(name) || 0\n      context.helpers.set(name, count + 1)\n      return name\n    },\n    removeHelper(name) {\n      const count = context.helpers.get(name)\n      if (count) {\n        const currentCount = count - 1\n        if (!currentCount) {\n          context.helpers.delete(name)\n        } else {\n          context.helpers.set(name, currentCount)\n        }\n      }\n    },\n    childIndex: 0,\n    onNodeRemoved: () => { },\n    removeNode(node) {\n      const list = context.parent.children\n      const removalIndex = node\n        ? list.indexOf(node)\n        : context.currentNode\n          ? context.childIndex\n          : -1\n      if (!node || node === context.currentNode) {\n        context.currentNode = null\n        context.onNodeRemoved()\n      } else {\n        // sibling node removed\n        if (context.childIndex > removalIndex) {\n          context.childIndex--\n          context.onNodeRemoved()\n        }\n      }\n      context.parent.children.splice(removalIndex, 1)\n    }\n\n  }\n\n  return context\n}\n\nfunction transformElement(node) {\n  if (node.type === NodeTypes.ELEMENT) {\n    return function postTransformElement() {\n      console.log('transform element', node)\n    }\n  }\n}\n\nfunction transformText(node: RootNode | TemplateChildNode) {\n  if (node.type === NodeTypes.ELEMENT || node.type === NodeTypes.ROOT) {\n    return () => {\n      let hasText = false\n      const children = node.children\n      const currentContainer = undefined // combine children\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i]\n        // if (isText(child)) {\n        //   hasText = true\n        // }\n      }\n    }\n  }\n}\n\nfunction transformExpression(node) {\n  if (node.type === NodeTypes.INTERPOLATION) {\n    // update content\n    node.content.content = `_ctx.${node.content.content}`\n  }\n}\n\nfunction traverseNode(\n  node: RootNode | TemplateChildNode,\n  context: TransformContext\n) {\n  context.currentNode = node\n\n  // apply transform plugins\n  const { nodeTransforms } = context\n  const exitFns = []\n  for (let i = 0; i < nodeTransforms.length; i++) {\n    const onExit = nodeTransforms[i](node, context)\n    if (onExit) {\n      if (isArray(onExit)) {\n        exitFns.push(...onExit)\n      } else {\n        exitFns.push(onExit)\n      }\n    }\n\n    if (!context.currentNode) {\n      // node was removed\n      return\n    } else {\n      // node may have been replaced\n      node = context.currentNode\n    }\n  }\n\n  switch (node.type) {\n    case NodeTypes.INTERPOLATION:\n      // no need to traverse, but we need to inject toString helper\n      context.helper(TO_DISPLAY_STRING)\n      break\n    case NodeTypes.ELEMENT:\n    case NodeTypes.ROOT:\n      traverseChildren(node, context)\n      break\n  }\n\n  // exit transforms\n  context.currentNode = node\n  let i = exitFns.length\n  while (i--) {\n    exitFns[i]()\n  }\n}\n\nfunction traverseChildren(\n  parent: ParentNode,\n  context: TransformContext\n) {\n  let i = 0\n  const nodeRemoved = () => {\n    i--\n  }\n\n  for (; i < parent.children?.length; i++) {\n    const child = parent.children[i]\n    if (isString(child)) continue\n    context.parent = parent\n    context.childIndex = i\n    context.onNodeRemoved = nodeRemoved\n    traverseNode(child, context)\n  }\n}", "import { generate } from \"./codegen\"\nimport { baseParse } from \"./parse\"\nimport { transform } from \"./transform\"\n\nexport function baseCompile(template) {\n  // 1. \u5C06\u6A21\u677F\u8F6C\u5316\u6210 ast \u6A21\u677F\n  const ast = baseParse(template)\n  // 2. \u5BF9 ast \u8BED\u6CD5\u6811\u8FDB\u884C\u8F6C\u5316\n  transform(ast)\n  // \u751F\u6210\u4EE3\u7801\n  return generate(ast)\n}"],
  "mappings": "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",
  "names": ["i"]
}
