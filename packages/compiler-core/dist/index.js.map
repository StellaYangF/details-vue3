{
  "version": 3,
  "sources": ["../src/codegen.ts", "../src/parse.ts", "../src/transform.ts", "../src/compile.ts"],
  "sourcesContent": ["export function generate(ast) { }", "import {\n  ElementNode,\n  InterpolationNode,\n  NodeTypes,\n  ParserContext,\n  Position,\n  SourceLocation,\n  TemplateChildNode,\n  TextNode\n} from \"./ast\"\n\nfunction createParserContext(content: string) {\n  return {\n    line: 1,\n    column: 1,\n    offset: 0,\n    source: content,\n    originalSource: content\n  }\n}\n\n// TODO: RootNode should be returned.\nexport function baseParse(content: string) {\n  const context = createParserContext(content)\n  return parseChildren(context)\n}\n\nfunction parseChildren(\n  context: ParserContext\n): TemplateChildNode[] {\n  debugger\n  const nodes: TemplateChildNode[] = []\n\n  while (!isEnd(context)) {\n    const s = context.source\n    let node\n    if (s.startsWith('{{')) {\n      node = parseInterpolation(context)\n    } else if (s[0] === '<') {\n      node = parseElement(context)\n    }\n    if (!node) {\n      node = parseText(context)\n    }\n\n    nodes.push(node)\n  }\n\n  return nodes\n}\n\nconst isEnd = (context: ParserContext): boolean => {\n  const source = context.source\n  if (context.source.startsWith('</')) { // denote no children\n    return true\n  }\n  return !source\n}\n\nfunction parseText(context): TextNode {\n  // Hello {{name}}</div> | Hello </div>{{name}}\n  const endTokens = ['<', '{']\n  let endIndex = context.source.length\n\n  for (let i = 0; i < endTokens.length; i++) {\n    const index = context.source.indexOf(endTokens[i], 1)\n    if (index !== -1 && endIndex > index) {\n      endIndex = index\n    }\n  }\n\n  let start = getCursor(context)\n  const content = parseTextData(context, endIndex)\n\n  return {\n    type: NodeTypes.TEXT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction getCursor(\n  context: ParserContext\n): Position {\n  const { column, line, offset } = context\n\n  return { column, line, offset }\n}\n\nfunction parseTextData(\n  context: ParserContext,\n  endIndex: number\n): string {\n\n  const rawText = context.source.slice(0, endIndex)\n  advanceBy(context, endIndex)\n  return rawText\n}\n\nfunction advanceBy(\n  context: ParserContext,\n  numberOfCharacters: number\n): void {\n  const s = context.source\n  advancePositionWithMutation(context, s, numberOfCharacters)\n  context.source = s.slice(numberOfCharacters)\n}\n\n// update context\nfunction advancePositionWithMutation(\n  pos: Position,\n  source: string,\n  numberOfCharacters: number\n): Position {\n  let linesCount = 0\n  let linePos = -1\n  for (let i = 0; i < numberOfCharacters; i++) {\n    if (source.charCodeAt(i) === 10) { // \\n new line\n      linesCount++\n      linePos = i\n    }\n  }\n  pos.offset += numberOfCharacters\n  pos.line += linesCount\n  pos.column = linePos === -1\n    ? pos.column + numberOfCharacters\n    : numberOfCharacters - linePos\n\n  return pos\n}\n\nfunction getSelection(\n  context: ParserContext,\n  start: Position,\n  end?: Position\n): SourceLocation {\n  end = end || getCursor(context)\n  return {\n    start,\n    end,\n    source: context.originalSource.slice(start.offset, end.offset)\n  }\n}\n\nfunction parseInterpolation(\n  context: ParserContext\n): InterpolationNode | undefined {\n  // {{state.name}}\n  const [open, close] = ['{{', '}}']\n  const closeIndex = context.source.indexOf(close, open.length)\n\n  if (closeIndex === -1) {\n    // EmitError\n    return undefined\n  }\n\n  const start = getCursor(context)\n  advanceBy(context, open.length)\n  const innerStart = getCursor(context)\n  const innerEnd = getCursor(context)\n  const rawContentLength = closeIndex - open.length\n  const rawContent = context.source.slice(0, rawContentLength)\n  const preTrimContent = parseTextData(context, rawContentLength)\n  const content = preTrimContent.trim()\n  const startOffset = preTrimContent.indexOf(content)\n  if (startOffset > 0) {\n    advancePositionWithMutation(innerStart, rawContent, startOffset)\n  }\n  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset)\n  advancePositionWithMutation(innerEnd, rawContent, endOffset)\n  advanceBy(context, close.length)\n\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      isStatic: false,\n      content,\n      loc: getSelection(context, innerStart, innerEnd)\n    },\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseElement(context: ParserContext): ElementNode | undefined {\n  const ele = parseTag(context, TagType.Start)\n  const children = parseChildren(context)\n\n  if (context.source.startsWith('</')) {\n    parseTag(context, TagType.End)\n  }\n  ele.loc = getSelection(context, ele.loc.start)\n  ele.children = children\n  return ele\n}\n\nconst enum TagType {\n  Start,\n  End\n}\n\nfunction parseTag(context: ParserContext, type: TagType.Start): ElementNode\nfunction parseTag(context: ParserContext, type: TagType.End): void\nfunction parseTag(context: ParserContext, type: TagType): ElementNode | undefined {\n  const start = getCursor(context)\n  // <div id=\"\"></div>\n  const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source)\n  const tag = match[1] // <div\n  advanceBy(context, match[0].length)\n  advanceSpaces(context)\n  const isSelfClosing = context.source.startsWith('/>') //<slot />\n  advanceBy(context, isSelfClosing ? 2 : 1)\n\n  if (type === TagType.End) {\n    return\n  }\n\n  return {\n    type: NodeTypes.ELEMENT,\n    tag,\n    isSelfClosing,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction advanceSpaces(context: ParserContext): void {\n  const match = /^[\\t\\r\\n]+/.exec(context.source) // null\n  if (match) {\n    advanceBy(context, match[0].length)\n  }\n}", "export function transform(root) { }", "import { generate } from \"./codegen\"\nimport { baseParse } from \"./parse\"\nimport { transform } from \"./transform\"\n\nexport function baseCompile(template) {\n  // 1. \u5C06\u6A21\u677F\u8F6C\u5316\u6210 ast \u6A21\u677F\n  const ast = baseParse(template)\n  console.log(ast)\n  // 2. \u5BF9 ast \u8BED\u6CD5\u6811\u8FDB\u884C\u8F6C\u5316\n  transform(ast)\n  // \u751F\u6210\u4EE3\u7801\n  return generate(ast)\n}"],
  "mappings": "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",
  "names": []
}
