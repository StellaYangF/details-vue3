{
  "version": 3,
  "sources": ["../src/codegen.ts", "../src/parse.ts", "../src/transform.ts", "../src/compile.ts"],
  "sourcesContent": ["export function generate(ast) { }", "import { NodeTypes } from \"./compile\"\n\nexport interface ParserContext {\n  readonly originalSource: string\n  source: string\n  line: number\n  column: number\n  offset: number\n}\n\n// ast.ts\nexport interface Position {\n  offset: number //from start of file\n  line: number,\n  column: number\n}\n\nexport interface SourceLocation {\n  start: Position\n  end: Position\n  source: string\n}\n\n// TODO: RootNode should be returned.\nexport function baseParse(content: string) {\n  const context = createParserContext(content)\n  return parseChildren(context)\n}\n\nexport interface Node {\n  type: NodeTypes\n  loc: SourceLocation\n}\n\nexport interface TextNode extends Node {\n  type: NodeTypes.TEXT\n  content: string\n}\n\nexport type TemplateChildNode =\n  | TextNode\n\nfunction createParserContext(content: string) {\n  return {\n    line: 1,\n    column: 1,\n    offset: 0,\n    source: content,\n    originalSource: content\n  }\n}\n\nfunction parseChildren(\n  context: ParserContext\n): TemplateChildNode[] {\n  const nodes: TemplateChildNode[] = []\n\n  while (!isEnd(context)) {\n    const s = context.source\n    let node\n    if (s.startsWith('{{')) {\n      // TODO: process expression\n      node = {}\n    } else if (s[0] === '<') {\n      // TODO: process element\n      node = {}\n    }\n    if (!node) {\n      // parseText\n      node = parseText(context)\n    }\n\n    nodes.push(node)\n    break\n  }\n\n  return nodes\n}\n\nconst isEnd = (context: ParserContext): boolean => !context.source\n\nfunction parseText(context): TextNode {\n  // Hello {{name}}</div> | Hello </div>{{name}}\n  const endTokens = ['<', '{']\n  let endIndex = context.source.length\n\n  for (let i = 0; i < endTokens.length; i++) {\n    const index = context.source.indexOf(endTokens[i], 1)\n    if (index !== -1 && endIndex > index) {\n      endIndex = index\n    }\n  }\n\n  let start = getCursor(context)\n  const content = parseTextData(context, endIndex)\n\n  return {\n    type: NodeTypes.TEXT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction getCursor(\n  context: ParserContext\n): Position {\n  const { column, line, offset } = context\n\n  return { column, line, offset }\n}\n\nfunction parseTextData(\n  context: ParserContext,\n  endIndex: number\n): string {\n\n  const rawText = context.source.slice(0, endIndex)\n  advanceBy(context, endIndex)\n  return rawText\n}\n\nfunction advanceBy(\n  context: ParserContext,\n  endIndex: number\n): void {\n  const s = context.source\n  advancePositionWithMutation(context, s, endIndex)\n  context.source = s.slice(endIndex)\n}\n\n// update context\nfunction advancePositionWithMutation(\n  context: ParserContext,\n  s: string,\n  endIndex: number\n): void {\n  let linesCount = 0\n  let linePos = -1\n  for (let i = 0; i < endIndex; i++) {\n    if (s.charCodeAt(i) === 10) { // \\n new line\n      linesCount++\n      linePos = i\n    }\n  }\n  context.offset += endIndex\n  context.line += linesCount\n\n  context.column = linePos === -1\n    ? context.column + endIndex\n    : endIndex - linePos\n}\n\nfunction getSelection(\n  context: ParserContext,\n  start: Position\n): SourceLocation {\n  const end = getCursor(context)\n  return {\n    start,\n    end,\n    source: context.originalSource.slice(start.offset, end.offset)\n  }\n}", "export function transform(root) { }", "import { generate } from \"./codegen\"\nimport { baseParse } from \"./parse\"\nimport { transform } from \"./transform\"\n\nexport function baseCompile(template) {\n  // 1. \u5C06\u6A21\u677F\u8F6C\u5316\u6210 ast \u6A21\u677F\n  const ast = baseParse(template)\n  // 2. \u5BF9 ast \u8BED\u6CD5\u6811\u8FDB\u884C\u8F6C\u5316\n  transform(ast)\n  // \u751F\u6210\u4EE3\u7801\n  return generate(ast)\n}\n\n// \u51C6\u5907\u8BED\u6CD5\u6811\u76F8\u5173type\nexport const enum NodeTypes {\n  ROOT,\n  ELEMENT,\n  TEXT,\n  COMMENT,\n  SIMPLE_EXPRESSION,\n  INTERPOLATION, // template expression\n  ATTRIBUTE,\n  DIRECTIVE,\n  COMPOUND_EXPRESSION,\n  IF,\n  IF_BRANCH,\n  FOR,\n  TEXT_CALL,\n  VNODE_CALL,\n  JS_CALL_EXPRESSION\n}"],
  "mappings": ";AAAO,SAAS,SAAS,KAAK;AAAE;;;ACwBzB,SAAS,UAAU,SAAiB;AACzC,QAAM,UAAU,oBAAoB,OAAO;AAC3C,SAAO,cAAc,OAAO;AAC9B;AAeA,SAAS,oBAAoB,SAAiB;AAC5C,SAAO;AAAA,IACL,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,gBAAgB;AAAA,EAClB;AACF;AAEA,SAAS,cACP,SACqB;AACrB,QAAM,QAA6B,CAAC;AAEpC,SAAO,CAAC,MAAM,OAAO,GAAG;AACtB,UAAM,IAAI,QAAQ;AAClB,QAAI;AACJ,QAAI,EAAE,WAAW,IAAI,GAAG;AAEtB,aAAO,CAAC;AAAA,IACV,WAAW,EAAE,CAAC,MAAM,KAAK;AAEvB,aAAO,CAAC;AAAA,IACV;AACA,QAAI,CAAC,MAAM;AAET,aAAO,UAAU,OAAO;AAAA,IAC1B;AAEA,UAAM,KAAK,IAAI;AACf;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,QAAQ,CAAC,YAAoC,CAAC,QAAQ;AAE5D,SAAS,UAAU,SAAmB;AAEpC,QAAM,YAAY,CAAC,KAAK,GAAG;AAC3B,MAAI,WAAW,QAAQ,OAAO;AAE9B,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,UAAM,QAAQ,QAAQ,OAAO,QAAQ,UAAU,CAAC,GAAG,CAAC;AACpD,QAAI,UAAU,MAAM,WAAW,OAAO;AACpC,iBAAW;AAAA,IACb;AAAA,EACF;AAEA,MAAI,QAAQ,UAAU,OAAO;AAC7B,QAAM,UAAU,cAAc,SAAS,QAAQ;AAE/C,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,KAAK,aAAa,SAAS,KAAK;AAAA,EAClC;AACF;AAEA,SAAS,UACP,SACU;AACV,QAAM,EAAE,QAAQ,MAAM,OAAO,IAAI;AAEjC,SAAO,EAAE,QAAQ,MAAM,OAAO;AAChC;AAEA,SAAS,cACP,SACA,UACQ;AAER,QAAM,UAAU,QAAQ,OAAO,MAAM,GAAG,QAAQ;AAChD,YAAU,SAAS,QAAQ;AAC3B,SAAO;AACT;AAEA,SAAS,UACP,SACA,UACM;AACN,QAAM,IAAI,QAAQ;AAClB,8BAA4B,SAAS,GAAG,QAAQ;AAChD,UAAQ,SAAS,EAAE,MAAM,QAAQ;AACnC;AAGA,SAAS,4BACP,SACA,GACA,UACM;AACN,MAAI,aAAa;AACjB,MAAI,UAAU;AACd,WAAS,IAAI,GAAG,IAAI,UAAU,KAAK;AACjC,QAAI,EAAE,WAAW,CAAC,MAAM,IAAI;AAC1B;AACA,gBAAU;AAAA,IACZ;AAAA,EACF;AACA,UAAQ,UAAU;AAClB,UAAQ,QAAQ;AAEhB,UAAQ,SAAS,YAAY,KACzB,QAAQ,SAAS,WACjB,WAAW;AACjB;AAEA,SAAS,aACP,SACA,OACgB;AAChB,QAAM,MAAM,UAAU,OAAO;AAC7B,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,QAAQ,QAAQ,eAAe,MAAM,MAAM,QAAQ,IAAI,MAAM;AAAA,EAC/D;AACF;;;AClKO,SAAS,UAAU,MAAM;AAAE;;;ACI3B,SAAS,YAAY,UAAU;AAEpC,QAAM,MAAM,UAAU,QAAQ;AAE9B,YAAU,GAAG;AAEb,SAAO,SAAS,GAAG;AACrB;",
  "names": []
}
