{
  "version": 3,
  "sources": ["../src/codegen.ts", "../src/parse.ts", "../src/transform.ts", "../src/compile.ts"],
  "sourcesContent": ["export function generate(ast) { }", "import { NodeTypes } from \"./compile\"\n\n\n\nexport interface ParserContext {\n  readonly originalSource: string\n  source: string\n  line: number\n  column: number\n  offset: number\n}\n\n// ast.ts\nexport interface Position {\n  offset: number //from start of file\n  line: number,\n  column: number\n}\n\nexport interface SourceLocation {\n  start: Position\n  end: Position\n  source: string\n}\n\n// TODO: RootNode should be returned.\nexport function baseParse(content: string) {\n  const context = createParserContext(content)\n  return parseChildren(context)\n}\n\nexport interface Node {\n  type: NodeTypes\n  loc: SourceLocation\n}\n\nexport interface TextNode extends Node {\n  type: NodeTypes.TEXT\n  content: string\n}\n\nexport interface SimpleExpressionNode extends Node {\n  type: NodeTypes.SIMPLE_EXPRESSION\n  content: string\n  isStatic: boolean\n}\nexport interface CompoundExpressionNode extends Node {\n  type: NodeTypes.COMPOUND_EXPRESSION\n  children: (\n    | SimpleExpressionNode\n    | CompoundExpressionNode\n    | InterpolationNode\n    | TextNode\n    | string\n    | symbol\n  )[]\n}\n\nexport type ExpressionNode = SimpleExpressionNode | CompoundExpressionNode\n\nexport interface InterpolationNode extends Node {\n  type: NodeTypes.INTERPOLATION\n  content: ExpressionNode\n}\n\nexport type TemplateChildNode =\n  | TextNode\n\nfunction createParserContext(content: string) {\n  return {\n    line: 1,\n    column: 1,\n    offset: 0,\n    source: content,\n    originalSource: content\n  }\n}\n\nfunction parseChildren(\n  context: ParserContext\n): TemplateChildNode[] {\n  const nodes: TemplateChildNode[] = []\n\n  while (!isEnd(context)) {\n    const s = context.source\n    let node\n    if (s.startsWith('{{')) {\n      // TODO: process expression\n      node = parseInterpolation(context)\n    } else if (s[0] === '<') {\n      // TODO: process element\n      node = {}\n    }\n    if (!node) {\n      // parseText\n      node = parseText(context)\n    }\n\n    nodes.push(node)\n    break\n  }\n\n  return nodes\n}\n\nconst isEnd = (context: ParserContext): boolean => !context.source\n\nfunction parseText(context): TextNode {\n  // Hello {{name}}</div> | Hello </div>{{name}}\n  const endTokens = ['<', '{']\n  let endIndex = context.source.length\n\n  for (let i = 0; i < endTokens.length; i++) {\n    const index = context.source.indexOf(endTokens[i], 1)\n    if (index !== -1 && endIndex > index) {\n      endIndex = index\n    }\n  }\n\n  let start = getCursor(context)\n  const content = parseTextData(context, endIndex)\n\n  return {\n    type: NodeTypes.TEXT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction getCursor(\n  context: ParserContext\n): Position {\n  const { column, line, offset } = context\n\n  return { column, line, offset }\n}\n\nfunction parseTextData(\n  context: ParserContext,\n  endIndex: number\n): string {\n\n  const rawText = context.source.slice(0, endIndex)\n  advanceBy(context, endIndex)\n  return rawText\n}\n\nfunction advanceBy(\n  context: ParserContext,\n  numberOfCharacters: number\n): void {\n  const s = context.source\n  advancePositionWithMutation(context, s, numberOfCharacters)\n  context.source = s.slice(numberOfCharacters)\n}\n\n// update context\nfunction advancePositionWithMutation(\n  pos: Position,\n  source: string,\n  numberOfCharacters: number\n): Position {\n  let linesCount = 0\n  let linePos = -1\n  for (let i = 0; i < numberOfCharacters; i++) {\n    if (source.charCodeAt(i) === 10) { // \\n new line\n      linesCount++\n      linePos = i\n    }\n  }\n  pos.offset += numberOfCharacters\n  pos.line += linesCount\n  pos.column = linePos === -1\n    ? pos.column + numberOfCharacters\n    : numberOfCharacters - linePos\n\n  return pos\n}\n\nfunction getSelection(\n  context: ParserContext,\n  start: Position,\n  end?: Position\n): SourceLocation {\n  end = end || getCursor(context)\n  return {\n    start,\n    end,\n    source: context.originalSource.slice(start.offset, end.offset)\n  }\n}\n\nfunction parseInterpolation(\n  context: ParserContext\n): InterpolationNode | undefined {\n  // {{state.name}}\n  const [open, close] = ['{{', '}}']\n  const closeIndex = context.source.indexOf(close, open.length)\n\n  if (closeIndex === -1) {\n    // EmitError\n    return undefined\n  }\n\n  const start = getCursor(context)\n  advanceBy(context, open.length)\n  const innerStart = getCursor(context)\n  const innerEnd = getCursor(context)\n  const rawContentLength = closeIndex - open.length\n  const rawContent = context.source.slice(0, rawContentLength)\n  const preTrimContent = parseTextData(context, rawContentLength)\n  const content = preTrimContent.trim()\n  const startOffset = preTrimContent.indexOf(content)\n  if (startOffset > 0) {\n    advancePositionWithMutation(innerStart, rawContent, startOffset)\n  }\n  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset)\n  advancePositionWithMutation(innerEnd, rawContent, endOffset)\n  advanceBy(context, close.length)\n\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      isStatic: false,\n      content,\n      loc: getSelection(context, innerStart, innerEnd)\n    },\n    loc: getSelection(context, start)\n  }\n}", "export function transform(root) { }", "import { generate } from \"./codegen\"\nimport { baseParse } from \"./parse\"\nimport { transform } from \"./transform\"\n\nexport function baseCompile(template) {\n  // 1. \u5C06\u6A21\u677F\u8F6C\u5316\u6210 ast \u6A21\u677F\n  const ast = baseParse(template)\n  console.log(ast)\n  // 2. \u5BF9 ast \u8BED\u6CD5\u6811\u8FDB\u884C\u8F6C\u5316\n  transform(ast)\n  // \u751F\u6210\u4EE3\u7801\n  return generate(ast)\n}\n\n// \u51C6\u5907\u8BED\u6CD5\u6811\u76F8\u5173type\nexport const enum NodeTypes {\n  ROOT,\n  ELEMENT,\n  TEXT,\n  COMMENT,\n  SIMPLE_EXPRESSION,\n  INTERPOLATION, // template expression\n  ATTRIBUTE,\n  DIRECTIVE,\n  COMPOUND_EXPRESSION,\n  IF,\n  IF_BRANCH,\n  FOR,\n  TEXT_CALL,\n  VNODE_CALL,\n  JS_CALL_EXPRESSION\n}"],
  "mappings": "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",
  "names": []
}
